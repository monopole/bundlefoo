The scheme will be

 1) Create some channels

 2) Create some objects, feeding them channels.

 3)   go obj1.run()
      go obj2.run()
      go obj3.run()

 4) Block on some quit channel.


Major objects are

*) Interpreter

   Converts app events into 'simpler' events

   Must be capable of telling everything to quit
   System might kill app, or user might rotate
   phone, or user might hit the quit button.


*) Screen

   An object with a collection of methods for
   drawing.  No threads.  No channels.  Just a
   view.

   Only one thread should have a reference to this.

*) model.go   Player, Ball, etc.

   Game interface - Players, SendBall, Quit Not
   used yet, and might not be important.

   This is held by the table, and it protect the
   table from knowing about v23 (if indeed the
   table ever ends up owning v23_manager).

*) server.go

   Implementation of GameBuddy VDL.

   Implements Recognize, Forget and Accept.

   Pulls stuff off the 'wire' and converts it into
   ptrs to objects with methods and sends them out
   on channels without blocking.  An instance of
   this impl is passed to ifc.GameBuddeyServer

   We could give this thing a quitter.  We have to
   have a new mutex member called 'isOff' or
   something.  Each method Recognize, Forget,
   Accept would have to get a lock on isOff, and
   only send data received by RPC into channels if
   not off.

   A method quit, or a quit channel, would get the
   lock, set the variable to false, and close all
   the outgoing channels, so anything waiting on a
   channel would get unblocked (e.g. a for range
   loop).

   On the other hand, v23 shutdown supposedly
   shuts down the network interface, so once it is
   called, no more data will be loaded on the
   channels.  There might already be live threads
   trying to load data on those channels, but
   that's because we chose to make it async.

   It might be cool to have the ability to toggle
   accepting messages from the network - i.e.,
   fire up the server, register in the namespace,
   but reject data, throwing it on the floor until
   ready, start accepting data, turn it off again,
   etc.  But could miss some important recognize
   messages this way.


   Regardless, should restructue this so that
   the service owns its outgoing channels, so one day
   it could have the option of closing them.

   Very cool example of multiple routines reading writing same channel.

   http://stackoverflow.com/questions/15715605/multiple-goroutines-listening-on-one-channel

   Since the quit command coming in from the network can only be consumed
   once, we need an orchestrator object, that can read that command
   then shut everything off in the proper order - convert one 'quit' into several


Clean fridge
clean bathrooms
vaccum all floors again


*) V23Manager

   Holds an instance of a v23 service, and many client instances.
   Uses an authorizer, dispatcher and initializer.  Accepts and emits
   data on channels.

   Accepts a ballChan to throw incoming balls on, and accepts a quit channel
   to send a quit message into the system. 
  It doesn't wait, since the quit is fired from the network thread.
  presumably whatever is on the other end of the channel
  tells the network thread to shut down.

*) V23Player - holds N client interface to some other player
   Can send a ball to the other player.

*) GameBuddy - the v23 service defined in player.vdl,
   held by V23Manager
   Defines Recognize, Forget, and Accept.

*) table.go  Thing that knows the positions of all the
             balls, which walls are transparent, where
             to send the balls, etc.

