TODO:  pass reley directly to engine, so it doesn't have to pass everything
through.

VOLLEY
	app.Main(func(a app.App) {
		nsRoot := "/" + game.DetermineNamespaceRoot()
		log.Printf("Using v23.namespace.root=%s", nsRoot)
		interpreter.NewInterpreter(
			config.Chatty,
			game.NewV23Manager(
				config.Chatty, config.RootName, nsRoot),
			screen.NewScreen(),
		).Run(a)
	})


MASTER
	if len(os.Args) < 2 {
		fmt.Println("need args")
		return
	}
	nsRoot := "/" + game.DetermineNamespaceRoot()
	log.Printf("Using v23.namespace.root=%s", nsRoot)
	gm := game.NewV23Manager(
		config.Chatty, config.RootName, nsRoot)
	if !gm.IsReadyToRun(true) {
		if config.Chatty {
			log.Printf("gm not ready!")
		}
		return
	}


NEW MAIN VOLLEY

  make a new manager

  Call a method on it that will return a channel that contains an
  instance of Relay that method should turn right away, but it should
  fire off a routine that won't write to the channel till the relay is
  ready.  Relay is then wrapped v23 server that converts incoming RPCs
  to data on channels.

  Inside the engine, the vmanager is called to 
    call IsReadyToRun - which calls v23.init, etc.
    call RunPrep (sends in 'throw ball channel) - , then go Run.
    call isRunning, before creating first ball, so we know startup worked.
    get Me, for printing and creating balls
    get channels with incoming data, e.g. MasterCommand, quit, pause, gravity
    call NoNewDoorsOrPeople
    call Stop



    * send the ballCommand channel as a final step to starting.
      That's how the engine tells the net stuff to throw a ball left or right.

    * call Run, so the engine tells rthe vm to enter its execute loop.

    * the engine tels the vm to stop accepting new balls or people, and tells
      it to stop.

    * the engine listens for commands from the vm, e.g. kick, freeze, etc.

    * engine listens for incoming balls.

    * door commands (because a player left)

    * in engine lifecycke on, the vm is asked if its ready to run, which is stupid,
      since a relay coming in on a channel woulld say the same thing

    * on a resize event, the vm is asked if it is running and if there are no
      balls, and it creates an event.

    * the engine asks the vm 'who am i', so it can create a ball for itself
      it would be better to ask the vm for a balll instead.


game
 authorizer
 dispatcher
 initializer
 v23_manager

    life cycle on does the following
       IsReadyToRun
       Can be called repeateldy, to see if stuff is up - but that's dumb,it should
       send something on a channel.
         * v23.Init, store shutdown function
         * v23.GetNamespace.setroots
         * glob the namespace for players,
         * figuring out my own number based on all the other players
         * is I am game master, then I'm done - no need to create a service.
         * make an instance of relay - the implementation of the v23 vdl
         * use it to make my own v23 server,
             with the proper auth,
             give it the relay instance,
             and tell it to start serving.

       RunPrep
         * accept and store the ballcommand channel, which comes from
           the engine (because the engine tels the manager to throw balls, 
           the manager has no concept of the screen or game action).
         * 'recognize' all other players, by creating client instances
           to talk to them, checking doors to see if we should open them.
         * sayHelloToEveryone - tell them to recognize me
        
       Run
         * checkdoors
         * select on channels forever, until something comes in on stop channel.


		IsRunning() bool {
		IsReadyToRun(isGameMaster bool) bool {

		RunPrep(chBc <-chan model.BallCommand) {
		Run() {
		Quit(id int) {
		Stop() {

		ChDoorCommand() <-chan model.DoorCommand {
		ChMasterCommand() <-chan ifc.MasterCommand {
		ChKick() <-chan bool {
		ChPauseDuration() <-chan float32 {
		ChGravity() <-chan float32 {
		ChIncomingBall() <-chan *model.Ball {
		ChQuit() <-chan bool {
		Me() *model.Player {
		List() {
		FireBall(count int) {
		DoMasterCommand(c string) {
		Kick() {
		SetPauseDuration(pd float32) {
		SetGravity(g float32) {
		NoNewBallsOrPeople() {


 v23_manager_test


interpreter
  Interpreter.Run()
    select a bunch of crap


relay
		StopAcceptingData() {
		ChRecognize() <-chan *model.Player {
		ChForget() <-chan *model.Player {
		ChIncomingBall() <-chan *model.Ball {
		ChQuit() <-chan bool {
		ChMasterCommand() <-chan ifc.MasterCommand {
		ChKick() <-chan bool {
		ChPauseDuration() <-chan float32 {
		ChGravity() <-chan float32 {
		DoMasterCommand(_ *context.T, _ rpc.ServerCall, mc ifc.MasterCommand) error {
		SetPauseDuration(_ *context.T, _ rpc.ServerCall, p float32) error {
		SetGravity(_ *context.T, _ rpc.ServerCall, g float32) error {
		Kick(_ *context.T, _ rpc.ServerCall) error {
		Quit(_ *context.T, _ rpc.ServerCall) error {
		Recognize(_ *context.T, _ rpc.ServerCall, p ifc.Player) error {
		Forget(_ *context.T, _ rpc.ServerCall, p ifc.Player) error {
		Accept(_ *context.T, _ rpc.ServerCall, b ifc.Ball) error {

screen
  NewScreen
  Start() {
  ReSize(width float32, height float32) {
  Width() float32 {
  Height() float32 {
  Clear() {
  Paint(balls []*model.Ball) {
  Stop() {



model
  ball  (owner, P, V)
  misc  ExecCommand, DoorState, Direction, DoorCommand
  model_test
  player (id)
  vec (x,y)


config
  config stuff

ifc
  Player (id)
  MasterCommand string
  Ball (owner, x, y, dx, dy)
  GameBuddy
    Recognize
    Forget
    Accept
    Quit
    Kick
    DoMasterCommand
    SetPauseDuration
    SetGravity

